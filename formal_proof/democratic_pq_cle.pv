set traceDisplay = long.
set attacker = active.
set ignoreTypes = false.

free broadcast_channel:channel.
free broadcast_channel_to_attacker:channel.
free node_2_1:channel.
free node_1_3:channel.
free node_2_3:channel.

free secret_to_transmit:bitstring [private].

type non_singular_matrix.

type skey.
type pkey.
fun pk(skey): pkey.
fun aenc(bitstring, pkey): bitstring.
reduc forall m: bitstring, k: skey; adec(aenc(m, pk(k)), k) = m.

type hsh.
fun hash(nat): hsh.

type key_init_vector. (* S_i *)
type witness_vector. (* R_i *)
fun witness_vector_to_bitstring(witness_vector): bitstring [data, typeConverter].
fun non_singular_matrices_to_witness(non_singular_matrix, non_singular_matrix): witness_vector.
fun get_witness_vector(skey): witness_vector.
fun retrieve_pubkey_verif(key_init_vector, hsh, witness_vector): pkey.
fun generate_private_key(non_singular_matrix, non_singular_matrix, hsh, key_init_vector): skey.
equation forall m1: non_singular_matrix, m2: non_singular_matrix, h: hsh, s: key_init_vector; pk(generate_private_key(m1, m2, h, s)) = retrieve_pubkey_verif(s, h, non_singular_matrices_to_witness(m1, m2)).
equation forall m1: non_singular_matrix, m2: non_singular_matrix, h: hsh, s: key_init_vector; get_witness_vector(generate_private_key(m1, m2, h, s)) = non_singular_matrices_to_witness(m1, m2).

type new_node_acceptance_signature.
fun generate_new_node_sig(hsh, non_singular_matrix, non_singular_matrix): new_node_acceptance_signature.
reduc forall h:hsh, m1: non_singular_matrix, m2: non_singular_matrix; check_acceptance_sig(generate_new_node_sig(h, m1, m2), non_singular_matrices_to_witness(m1, m2)) = h.
fun sig_to_key_init_vector(new_node_acceptance_signature): key_init_vector [data, typeConverter].

(* Signature *)
type sskey.
type spkey.
fun spk(sskey): spkey.
fun sign(bitstring, sskey): bitstring.
reduc forall m: bitstring, k: sskey; getmess(sign(m, k)) = m.
reduc forall m: bitstring, k: sskey; checksign(sign(m, k), spk(k)) = m.
reduc forall m: bitstring, k: sskey; get_signing_key(sign(m, k)) = spk(k).

type shares2_new_node_acceptance_signature.
type shares2_part_1_new_node_acceptance_signature.
type shares2_part_2_new_node_acceptance_signature.
fun generate_shares_2_new_node_sig(hsh, non_singular_matrix, non_singular_matrix): shares2_new_node_acceptance_signature.
fun extract_shares2_part_1_new_node_acceptance_signature(shares2_new_node_acceptance_signature): shares2_part_1_new_node_acceptance_signature.
fun extract_shares2_part_2_new_node_acceptance_signature(shares2_new_node_acceptance_signature): shares2_part_2_new_node_acceptance_signature.
reduc forall h:hsh, m1: non_singular_matrix, m2: non_singular_matrix; check_share2_acceptance_sig_part_1(extract_shares2_part_1_new_node_acceptance_signature(generate_shares_2_new_node_sig(h, m1, m2)), non_singular_matrices_to_witness(m1, m2)) = h.
reduc forall h:hsh, m1: non_singular_matrix, m2: non_singular_matrix; check_share2_acceptance_sig_part_2(extract_shares2_part_2_new_node_acceptance_signature(generate_shares_2_new_node_sig(h, m1, m2)), non_singular_matrices_to_witness(m1, m2)) = h.
fun shares2_sig_to_key_init_vector(shares2_part_1_new_node_acceptance_signature, shares2_part_2_new_node_acceptance_signature): key_init_vector [data].

table sig_public_keys(nat, spkey).

event node_signature_generated(nat, non_singular_matrix, non_singular_matrix).
event public_key_broadcast(nat, new_node_acceptance_signature).
event node_signature_generated_share2(nat, nat, non_singular_matrix, non_singular_matrix).
event public_key_broadcast_share2(nat, shares2_part_1_new_node_acceptance_signature, shares2_part_2_new_node_acceptance_signature).
event test_reachability(nat).

query attacker(secret_to_transmit).
query m1:non_singular_matrix, m2: non_singular_matrix, node_id: nat; inj-event(public_key_broadcast(node_id, generate_new_node_sig(hash(node_id), m1, m2))) ==> inj-event(node_signature_generated(node_id, m1, m2)).
query node1_hi2:non_singular_matrix, node1_hi3: non_singular_matrix, node2_hi2:non_singular_matrix, node2_hi3: non_singular_matrix, new_node_id: nat; inj-event(public_key_broadcast_share2(new_node_id, extract_shares2_part_1_new_node_acceptance_signature(generate_shares_2_new_node_sig(hash(new_node_id), node1_hi2, node1_hi3)), extract_shares2_part_2_new_node_acceptance_signature(generate_shares_2_new_node_sig(hash(new_node_id), node2_hi2, node2_hi3)))) ==> inj-event(node_signature_generated_share2(1, new_node_id, node1_hi2, node1_hi3)) && inj-event(node_signature_generated_share2(2, new_node_id, node2_hi2, node2_hi3)).
(*
The reachability fail if the code is reachable.
Uncomment to check reachability.
If the test fails, the code is reachable.
*)
(*
query event(test_reachability(1)).
query event(test_reachability(2)).
query event(test_reachability(3)).
query event(test_reachability(1)) && event(test_reachability(2)) && event(test_reachability(3)).
*)

let node_1(node_id:nat, ssk:sskey, s_i_1:key_init_vector) =
    let hi_1 = hash(node_id) in
    new hi_2:non_singular_matrix;
    new hi_3:non_singular_matrix;
    let private_key = generate_private_key(hi_2, hi_3, hi_1, s_i_1) in
    let r_i = non_singular_matrices_to_witness(hi_2, hi_3) in
    out(broadcast_channel, (r_i, sign(witness_vector_to_bitstring(r_i), ssk)));
    sync 1 [node1];
    event node_signature_generated(2, hi_2, hi_3);
    out(node_2_1, generate_new_node_sig(hash(2), hi_2, hi_3));
    in(broadcast_channel, (node_2_pk:pkey, node2_acceptance_sig:new_node_acceptance_signature, node_2_si:key_init_vector, node_2_ri:witness_vector, node_2_ri_sign:bitstring));
    get sig_public_keys(=2, node_2_psk) in
    get sig_public_keys(=3, node_3_psk) in
    let (=witness_vector_to_bitstring(node_2_ri)) = checksign(node_2_ri_sign, node_2_psk) in
    let (=hash(2)) = check_acceptance_sig(node2_acceptance_sig, r_i) in
    let (=node_2_si) = sig_to_key_init_vector(node2_acceptance_sig) in
    let (=node_2_pk) = retrieve_pubkey_verif(node_2_si, hash(2), node_2_ri) in
    out(node_2_1, aenc(secret_to_transmit, node_2_pk));
    in(node_2_1, secret_enc:bitstring);
    sync 2 [node1];
    let (=secret_to_transmit) = adec(secret_enc, private_key) in
    event node_signature_generated_share2(1, 3, hi_2, hi_3);
    out(node_1_3, extract_shares2_part_1_new_node_acceptance_signature(generate_shares_2_new_node_sig(hash(3), hi_2, hi_3)));
    in(broadcast_channel, (node_3_pk:pkey, node3_acceptance_sig_node1:shares2_part_1_new_node_acceptance_signature, node3_acceptance_sig_node2:shares2_part_2_new_node_acceptance_signature, node_3_si:key_init_vector, node_3_ri:witness_vector, node_3_ri_sign:bitstring));
    let (=witness_vector_to_bitstring(node_3_ri)) = checksign(node_3_ri_sign, node_3_psk) in
    let (=hash(3)) = check_share2_acceptance_sig_part_1(node3_acceptance_sig_node1, r_i) in
    let (=hash(3)) = check_share2_acceptance_sig_part_2(node3_acceptance_sig_node2, node_2_ri) in
    let (=node_3_si) = shares2_sig_to_key_init_vector(node3_acceptance_sig_node1, node3_acceptance_sig_node2) in
    let (=node_3_pk) = retrieve_pubkey_verif(node_3_si, hash(3), node_3_ri) in
    out(node_1_3, aenc(secret_to_transmit, node_3_pk));
    in(node_1_3, secret_enc:bitstring);
    let (=secret_to_transmit) = adec(secret_enc, private_key) in
    event test_reachability(1);
    0.

let node_2(node_id:nat, ssk:sskey, s_i_1:key_init_vector) =
    in(broadcast_channel, (witness_node_1:witness_vector, witness_node_1_sign:bitstring));
    sync 1 [node2];
    get sig_public_keys(=1, node_1_psk) in
    get sig_public_keys(=3, node_3_psk) in
    let (=witness_vector_to_bitstring(witness_node_1)) = checksign(witness_node_1_sign, node_1_psk) in
    let hi_1 = hash(node_id) in
    let node_1_pk = retrieve_pubkey_verif(s_i_1, hash(1), witness_node_1) in
    in(node_2_1, node_acceptance_sig:new_node_acceptance_signature);
    let (=hi_1) = check_acceptance_sig(node_acceptance_sig, witness_node_1) in
    new hi_2:non_singular_matrix;
    new hi_3:non_singular_matrix;
    let s_i = sig_to_key_init_vector(node_acceptance_sig) in
    let private_key = generate_private_key(hi_2, hi_3, hi_1, s_i) in
    let r_i = get_witness_vector(private_key) in
    out(broadcast_channel, (pk(private_key), node_acceptance_sig, s_i, r_i, sign(witness_vector_to_bitstring(r_i), ssk)));
    event public_key_broadcast(2, node_acceptance_sig);
    in(node_2_1, secret_enc:bitstring);
    let (=secret_to_transmit) = adec(secret_enc, private_key) in
    out(node_2_1, aenc(secret_to_transmit, node_1_pk));
    sync 2 [node2];
    event node_signature_generated_share2(2, 3, hi_2, hi_3);
    out(node_2_3, extract_shares2_part_2_new_node_acceptance_signature(generate_shares_2_new_node_sig(hash(3), hi_2, hi_3)));
    in(broadcast_channel, (node_3_pk:pkey, node3_acceptance_sig_node1:shares2_part_1_new_node_acceptance_signature, node3_acceptance_sig_node2:shares2_part_2_new_node_acceptance_signature, node_3_si:key_init_vector, node_3_ri:witness_vector, node_3_ri_sign:bitstring));
    let (=witness_vector_to_bitstring(node_3_ri)) = checksign(node_3_ri_sign, node_3_psk) in
    let (=hash(3)) = check_share2_acceptance_sig_part_1(node3_acceptance_sig_node1, witness_node_1) in
    let (=hash(3)) = check_share2_acceptance_sig_part_2(node3_acceptance_sig_node2, r_i) in
    let (=node_3_si) = shares2_sig_to_key_init_vector(node3_acceptance_sig_node1, node3_acceptance_sig_node2) in
    let (=node_3_pk) = retrieve_pubkey_verif(node_3_si, hash(3), node_3_ri) in
    out(node_2_3, aenc(secret_to_transmit, node_3_pk));
    in(node_2_3, secret_enc:bitstring);
    let (=secret_to_transmit) = adec(secret_enc, private_key) in
    event test_reachability(2);
    0.

let node_3(node_id:nat, ssk:sskey, s_i_1:key_init_vector) =
    in(broadcast_channel, (witness_node_1:witness_vector, witness_node_1_sign:bitstring));
    sync 1 [node3];
    get sig_public_keys(=1, node_1_psk) in
    get sig_public_keys(=2, node_2_psk) in
    let (=witness_vector_to_bitstring(witness_node_1)) = checksign(witness_node_1_sign, node_1_psk) in
    let hi_1 = hash(node_id) in
    let node_1_pk = retrieve_pubkey_verif(s_i_1, hash(1), witness_node_1) in
    in(broadcast_channel, (node_2_pk:pkey, node2_acceptance_sig:new_node_acceptance_signature, node_2_si:key_init_vector, node_2_ri:witness_vector, node_2_ri_sign:bitstring));
    let (=witness_vector_to_bitstring(node_2_ri)) = checksign(node_2_ri_sign, node_2_psk) in
    let (=hash(2)) = check_acceptance_sig(node2_acceptance_sig, witness_node_1) in
    let (=node_2_si) = sig_to_key_init_vector(node2_acceptance_sig) in
    let (=node_2_pk) = retrieve_pubkey_verif(node_2_si, hash(2), node_2_ri) in
    sync 2 [node3];
    in(node_1_3, node1_acceptance_sig:shares2_part_1_new_node_acceptance_signature);
    in(node_2_3, node2_acceptance_sig:shares2_part_2_new_node_acceptance_signature);
    let (=hi_1) = check_share2_acceptance_sig_part_1(node1_acceptance_sig, witness_node_1) in
    let (=hi_1) = check_share2_acceptance_sig_part_2(node2_acceptance_sig, node_2_ri) in
    new hi_2:non_singular_matrix;
    new hi_3:non_singular_matrix;
    let s_i = shares2_sig_to_key_init_vector(node1_acceptance_sig, node2_acceptance_sig) in
    let private_key = generate_private_key(hi_2, hi_3, hi_1, s_i) in
    let r_i = get_witness_vector(private_key) in
    out(broadcast_channel, (pk(private_key), node1_acceptance_sig, node2_acceptance_sig, s_i, r_i, sign(witness_vector_to_bitstring(r_i), ssk)));
    event public_key_broadcast_share2(3, node1_acceptance_sig, node2_acceptance_sig);
    in(node_1_3, secret_enc:bitstring);
    let (=secret_to_transmit) = adec(secret_enc, private_key) in
    in(node_2_3, secret_enc:bitstring);
    let (=secret_to_transmit) = adec(secret_enc, private_key) in
    out(node_1_3, aenc(secret_to_transmit, node_1_pk));
    out(node_2_3, aenc(secret_to_transmit, node_2_pk));
    event test_reachability(3);
    0.

process
    new node_1_ssk:sskey; (* signature are here in order to "emulate" id-based encryption, as we assume witness vector cannot be modified *)
    let node_1_psk = spk(node_1_ssk) in
    insert sig_public_keys(1, node_1_psk);
    new node_2_ssk:sskey;
    let node_2_psk = spk(node_2_ssk) in
    insert sig_public_keys(2, node_2_psk);
    new node_3_ssk:sskey;
    let node_3_psk = spk(node_3_ssk) in
    insert sig_public_keys(3, node_3_psk);
    new s_i_1:key_init_vector; (* Init vector of node 1 *)
    out(broadcast_channel_to_attacker, s_i_1); (* The init vector is broadcasted *)
    node_1(1, node_1_ssk, s_i_1) | node_2(2, node_2_ssk, s_i_1) | node_3(3, node_3_ssk, s_i_1)
